{
  "version": 3,
  "sources": ["../../src/MedplumProvider/MedplumProvider.tsx", "../../src/MedplumProvider/MedplumProvider.context.ts", "../../src/useCachedBinaryUrl/useCachedBinaryUrl.ts", "../../src/usePrevious/usePrevious.ts", "../../src/useResource/useResource.ts", "../../src/useSearch/useSearch.ts", "../../src/useDebouncedValue/useDebouncedValue.ts", "../../src/useSubscription/useSubscription.ts"],
  "sourcesContent": ["import { MedplumClient, MedplumClientEventMap } from '@medplum/core';\nimport { ReactNode, useEffect, useMemo, useState } from 'react';\nimport { MedplumNavigateFunction, reactContext } from './MedplumProvider.context';\n\nexport interface MedplumProviderProps {\n  readonly medplum: MedplumClient;\n  readonly navigate?: MedplumNavigateFunction;\n  readonly children: ReactNode;\n}\n\nconst EVENTS_TO_TRACK = [\n  'change',\n  'storageInitialized',\n  'storageInitFailed',\n  'profileRefreshing',\n  'profileRefreshed',\n] satisfies (keyof MedplumClientEventMap)[];\n\n/**\n * The MedplumProvider component provides Medplum context state.\n *\n * Medplum context includes:\n *   1) medplum - Medplum client library\n *   2) profile - The current user profile (if signed in)\n * @param props - The MedplumProvider React props.\n * @returns The MedplumProvider React node.\n */\nexport function MedplumProvider(props: MedplumProviderProps): JSX.Element {\n  const medplum = props.medplum;\n  const navigate = props.navigate ?? defaultNavigate;\n\n  const [state, setState] = useState({\n    profile: medplum.getProfile(),\n    loading: medplum.isLoading(),\n  });\n\n  useEffect(() => {\n    function eventListener(): void {\n      setState((s) => ({\n        ...s,\n        profile: medplum.getProfile(),\n        loading: medplum.isLoading(),\n      }));\n    }\n\n    for (const event of EVENTS_TO_TRACK) {\n      medplum.addEventListener(event, eventListener);\n    }\n    return () => {\n      for (const event of EVENTS_TO_TRACK) {\n        medplum.removeEventListener(event, eventListener);\n      }\n    };\n  }, [medplum]);\n\n  const medplumContext = useMemo(\n    () => ({\n      ...state,\n      medplum,\n      navigate,\n    }),\n    [state, medplum, navigate]\n  );\n\n  return <reactContext.Provider value={medplumContext}>{props.children}</reactContext.Provider>;\n}\n\n/**\n * The default \"navigate\" function which simply uses window.location.href.\n * @param path - The path to navigate to.\n */\nfunction defaultNavigate(path: string): void {\n  window.location.assign(path);\n}\n", "import { MedplumClient, ProfileResource } from '@medplum/core';\nimport { createContext, useContext } from 'react';\n\nexport const reactContext = createContext(undefined as MedplumContext | undefined);\n\nexport type MedplumNavigateFunction = (path: string) => void;\n\nexport interface MedplumContext {\n  medplum: MedplumClient;\n  navigate: MedplumNavigateFunction;\n  profile?: ProfileResource;\n  loading: boolean;\n}\n\n/**\n * Returns the MedplumContext instance.\n * @returns The MedplumContext instance.\n */\nexport function useMedplumContext(): MedplumContext {\n  return useContext(reactContext) as MedplumContext;\n}\n\n/**\n * Returns the MedplumClient instance.\n * This is a shortcut for useMedplumContext().medplum.\n * @returns The MedplumClient instance.\n */\nexport function useMedplum(): MedplumClient {\n  return useMedplumContext().medplum;\n}\n\n/**\n * Returns the Medplum navigate function.\n * @returns The Medplum navigate function.\n */\nexport function useMedplumNavigate(): MedplumNavigateFunction {\n  return useMedplumContext().navigate;\n}\n\n/**\n * Returns the current Medplum user profile (if signed in).\n * This is a shortcut for useMedplumContext().profile.\n * @returns The current user profile.\n */\nexport function useMedplumProfile(): ProfileResource | undefined {\n  return useMedplumContext().profile;\n}\n", "import { useMemo } from 'react';\n\n// Maintain a cache of urls to avoid unnecessary re-download of attachments\n// The following is a workaround for the fact that each request to a resource containing a Binary data reference\n// returns a NEW signed S3 URL for each bypassing the native browser caching mechanism\n// resulting in unnecessary bandwidth consumption.\n// https://www.medplum.com/docs/fhir-datastore/binary-data#consuming-a-fhir-binary-in-an-application\n// https://github.com/medplum/medplum/issues/3815\n\n// The S3 presigned URLs expire after 1 hour with the default configuration and hard refreshes are not uncommon even in SPAs so this\n// could be a good way to get additional cache hits\n// This would require additional logic for initialization, saving, and purging of expired keys\nconst urls = new Map<string, string>();\n\nexport const useCachedBinaryUrl = (binaryUrl: string | undefined): string | undefined => {\n  return useMemo(() => {\n    if (!binaryUrl) {\n      return undefined;\n    }\n\n    const binaryResourceUrl = binaryUrl.split('?')[0];\n    if (!binaryResourceUrl) {\n      return binaryUrl;\n    }\n\n    // Check if the binaryUrl is a presigned S3 URL\n    let binaryUrlSearchParams: URLSearchParams;\n    try {\n      binaryUrlSearchParams = new URLSearchParams(new URL(binaryUrl).search);\n    } catch (_err) {\n      return binaryUrl;\n    }\n\n    if (!binaryUrlSearchParams.has('Key-Pair-Id') || !binaryUrlSearchParams.has('Signature')) {\n      return binaryUrl;\n    }\n\n    // https://stackoverflow.com/questions/23929145/how-to-test-if-a-given-time-stamp-is-in-seconds-or-milliseconds\n    const binaryUrlExpires = binaryUrlSearchParams.get('Expires');\n    if (!binaryUrlExpires || binaryUrlExpires.length > 13) {\n      // Expires is expected to be in seconds, not milliseconds\n      return binaryUrl;\n    }\n\n    const cachedUrl = urls.get(binaryResourceUrl);\n    if (cachedUrl) {\n      const searchParams = new URLSearchParams(new URL(cachedUrl).search);\n\n      // This is fairly brittle as it relies on the current structure of the Medplum returned URL\n      const expires = searchParams.get('Expires');\n\n      // `expires` is in seconds, Date.now() is in ms\n      // Add padding to mitigate expiration between time of check and time of use\n      if (expires && parseInt(expires, 10) * 1000 - 5_000 > Date.now()) {\n        return cachedUrl;\n      }\n    }\n\n    urls.set(binaryResourceUrl, binaryUrl);\n    return binaryUrl;\n  }, [binaryUrl]);\n};\n", "import { useEffect, useRef } from 'react';\n\n/**\n * React Hook to keep track of the passed-in value from the previous render of the containing component.\n * @param value - The value to track.\n * @returns The value passed in from the previous render.\n */\nexport function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n", "import { deepEquals, isReference, isResource, MedplumClient, normalizeOperationOutcome } from '@medplum/core';\nimport { OperationOutcome, Reference, Resource } from '@medplum/fhirtypes';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useMedplum } from '../MedplumProvider/MedplumProvider.context';\n\n/**\n * React Hook to use a FHIR reference.\n * Handles the complexity of resolving references and caching resources.\n * @param value - The resource or reference to resource.\n * @param setOutcome - Optional callback to set the OperationOutcome.\n * @returns The resolved resource.\n */\nexport function useResource<T extends Resource>(\n  value: Reference<T> | Partial<T> | undefined,\n  setOutcome?: (outcome: OperationOutcome) => void\n): T | undefined {\n  const medplum = useMedplum();\n  const [resource, setResource] = useState<T | undefined>(() => {\n    return getInitialResource(medplum, value);\n  });\n\n  const setResourceIfChanged = useCallback(\n    (r: T | undefined) => {\n      if (!deepEquals(r, resource)) {\n        setResource(r);\n      }\n    },\n    [resource]\n  );\n\n  useEffect(() => {\n    let subscribed = true;\n\n    const newValue = getInitialResource(medplum, value);\n    if (!newValue && isReference(value)) {\n      medplum\n        .readReference(value as Reference<T>)\n        .then((r) => {\n          if (subscribed) {\n            setResourceIfChanged(r);\n          }\n        })\n        .catch((err) => {\n          if (subscribed) {\n            setResourceIfChanged(undefined);\n            if (setOutcome) {\n              setOutcome(normalizeOperationOutcome(err));\n            }\n          }\n        });\n    } else {\n      setResourceIfChanged(newValue);\n    }\n\n    return (() => (subscribed = false)) as () => void;\n  }, [medplum, value, setResourceIfChanged, setOutcome]);\n\n  return resource;\n}\n\n/**\n * Returns the initial resource value based on the input value.\n * If the input value is a resource, returns the resource.\n * If the input value is a reference to a resource available in the cache, returns the resource.\n * Otherwise, returns undefined.\n * @param medplum - The medplum client.\n * @param value - The resource or reference to resource.\n * @returns An initial resource if available; undefined otherwise.\n */\nfunction getInitialResource<T extends Resource>(\n  medplum: MedplumClient,\n  value: Reference<T> | Partial<T> | undefined\n): T | undefined {\n  if (value) {\n    if (isResource(value)) {\n      return value as T;\n    }\n\n    if (isReference(value)) {\n      return medplum.getCachedReference(value as Reference<T>);\n    }\n  }\n\n  return undefined;\n}\n", "import { allOk, normalizeOperationOutcome, QueryTypes, ResourceArray } from '@medplum/core';\nimport { Bundle, ExtractResource, OperationOutcome, ResourceType } from '@medplum/fhirtypes';\nimport { useEffect, useState } from 'react';\nimport { useMedplum } from '../MedplumProvider/MedplumProvider.context';\nimport { useDebouncedValue } from '../useDebouncedValue/useDebouncedValue';\n\ntype SearchFn = 'search' | 'searchOne' | 'searchResources';\nexport type SearchOptions = { debounceMs?: number };\n\nconst DEFAULT_DEBOUNCE_MS = 250;\n\n/**\n * React hook for searching FHIR resources.\n *\n * This is a convenience hook for calling the MedplumClient.search() method.\n *\n * @param resourceType - The FHIR resource type to search.\n * @param query - Optional search parameters.\n * @param options - Optional options for configuring the search.\n * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.\n */\nexport function useSearch<K extends ResourceType>(\n  resourceType: K,\n  query?: QueryTypes,\n  options?: SearchOptions\n): [Bundle<ExtractResource<K>> | undefined, boolean, OperationOutcome | undefined] {\n  return useSearchImpl<K, Bundle<ExtractResource<K>>>('search', resourceType, query, options);\n}\n\n/**\n * React hook for searching for a single FHIR resource.\n *\n * This is a convenience hook for calling the MedplumClient.searchOne() method.\n *\n * @param resourceType - The FHIR resource type to search.\n * @param query - Optional search parameters.\n * @param options - Optional options for configuring the search.\n * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.\n */\nexport function useSearchOne<K extends ResourceType>(\n  resourceType: K,\n  query?: QueryTypes,\n  options?: SearchOptions\n): [ExtractResource<K> | undefined, boolean, OperationOutcome | undefined] {\n  return useSearchImpl<K, ExtractResource<K>>('searchOne', resourceType, query, options);\n}\n\n/**\n * React hook for searching for an array of FHIR resources.\n *\n * This is a convenience hook for calling the MedplumClient.searchResources() method.\n *\n * @param resourceType - The FHIR resource type to search.\n * @param query - Optional search parameters.\n * @param options - Optional options for configuring the search.\n * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.\n */\nexport function useSearchResources<K extends ResourceType>(\n  resourceType: K,\n  query?: QueryTypes,\n  options?: SearchOptions\n): [ResourceArray<ExtractResource<K>> | undefined, boolean, OperationOutcome | undefined] {\n  return useSearchImpl<K, ResourceArray<ExtractResource<K>>>('searchResources', resourceType, query, options);\n}\n\nfunction useSearchImpl<K extends ResourceType, SearchReturnType>(\n  searchFn: SearchFn,\n  resourceType: K,\n  query: QueryTypes | undefined,\n  options?: SearchOptions\n): [SearchReturnType | undefined, boolean, OperationOutcome | undefined] {\n  const medplum = useMedplum();\n  const [lastSearchKey, setLastSearchKey] = useState<string>();\n  const [loading, setLoading] = useState<boolean>(true);\n  const [result, setResult] = useState<SearchReturnType>();\n  const [outcome, setOutcome] = useState<OperationOutcome>();\n\n  const searchKey = medplum.fhirSearchUrl(resourceType, query).toString();\n  const [debouncedSearchKey] = useDebouncedValue(searchKey, options?.debounceMs ?? DEFAULT_DEBOUNCE_MS, {\n    leading: true,\n  });\n\n  useEffect(() => {\n    if (debouncedSearchKey !== lastSearchKey) {\n      setLastSearchKey(debouncedSearchKey);\n      medplum[searchFn](resourceType, query)\n        .then((res) => {\n          setLoading(false);\n          setResult(res as SearchReturnType);\n          setOutcome(allOk);\n        })\n        .catch((err) => {\n          setLoading(false);\n          setResult(undefined);\n          setOutcome(normalizeOperationOutcome(err));\n        });\n    }\n  }, [medplum, searchFn, resourceType, query, lastSearchKey, debouncedSearchKey]);\n\n  return [result, loading, outcome];\n}\n", "/*\n  This hook was forked from: https://github.com/mantinedev/mantine/blob/fbcee929e0b11782092f48c1e7af2a1d1c878823/packages/%40mantine/hooks/src/use-debounced-value/use-debounced-value.ts\n  and has the following license:\n\n  MIT License\n\n  Copyright (c) 2021 Vitaly Rtishchev\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nexport type UseDebouncedValueOptions = {\n  /** Whether the first update to `value` should be immediate or not */\n  leading?: boolean;\n};\n\n/**\n * This hook allows users to debounce an incoming value by a specified number of milliseconds.\n *\n * Users can also specify whether the first update to `value` in a sequence of rapid updates should be immediate, by specifying `leading: true` in the options.\n * The default value for `leading` is `false`.\n *\n * The return value is a tuple containing the debounced value at `arr[0]` and a function to cancel the pending debounced value change at `arr[1]`.\n *\n * @param value - The value to debounce.\n * @param waitMs - How long in milliseconds should.\n * @param options - Optional options for configuring the debounce.\n * @returns An array tuple of `[debouncedValue, cancelFn]`.\n */\nexport function useDebouncedValue<T = any>(\n  value: T,\n  waitMs: number,\n  options: UseDebouncedValueOptions = { leading: false }\n): [T, () => void] {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  const mountedRef = useRef(false);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const cooldownRef = useRef(false);\n\n  const cancel = useCallback(() => window.clearTimeout(timeoutRef.current), []);\n\n  useEffect(() => {\n    if (mountedRef.current) {\n      if (!cooldownRef.current && options.leading) {\n        cooldownRef.current = true;\n        setDebouncedValue(value);\n      } else {\n        cancel();\n        timeoutRef.current = setTimeout(() => {\n          cooldownRef.current = false;\n          setDebouncedValue(value);\n        }, waitMs);\n      }\n    }\n  }, [value, options.leading, waitMs, cancel]);\n\n  useEffect(() => {\n    mountedRef.current = true;\n    return cancel;\n  }, [cancel]);\n\n  return [debouncedValue, cancel] as const;\n}\n", "import { SubscriptionEmitter, SubscriptionEventMap, deepEquals } from '@medplum/core';\nimport { Bundle, Subscription } from '@medplum/fhirtypes';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { useMedplum } from '../MedplumProvider/MedplumProvider.context';\n\nconst SUBSCRIPTION_DEBOUNCE_MS = 3000;\n\nexport type UseSubscriptionOptions = {\n  subscriptionProps?: Partial<Subscription>;\n  onWebSocketOpen?: () => void;\n  onWebSocketClose?: () => void;\n  onSubscriptionConnect?: (subscriptionId: string) => void;\n  onSubscriptionDisconnect?: (subscriptionId: string) => void;\n  onError?: (err: Error) => void;\n};\n\n/**\n * Creates an in-memory `Subscription` resource with the given criteria on the Medplum server and calls the given callback when an event notification is triggered by a resource interaction over a WebSocket connection.\n *\n * Subscriptions created with this hook are lightweight, share a single WebSocket connection, and are automatically untracked and cleaned up when the containing component is no longer mounted.\n *\n * @param criteria - The FHIR search criteria to subscribe to.\n * @param callback - The callback to call when a notification event `Bundle` for this `Subscription` is received.\n * @param options - Optional options used to configure the created `Subscription`. See {@link UseSubscriptionOptions}\n *\n * --------------------------------------------------------------------------------------------------------------------------------\n *\n * `options` contains the following properties, all of which are optional:\n * - `subscriptionProps` - Allows the caller to pass a `Partial<Subscription>` to use as part of the creation\n * of the `Subscription` resource for this subscription. It enables the user namely to pass things like the `extension` property and to create\n * the `Subscription` with extensions such the {@link https://www.medplum.com/docs/subscriptions/subscription-extensions#interactions | Supported Interaction} extension which would enable to listen for `create` or `update` only events.\n * - `onWebsocketOpen` - Called when the WebSocket connection is established with Medplum server.\n * - `onWebsocketClose` - Called when the WebSocket connection disconnects.\n * - `onSubscriptionConnect` - Called when the corresponding subscription starts to receive updates after the subscription has been initialized and connected to.\n * - `onSubscriptionDisconnect` - Called when the corresponding subscription is destroyed and stops receiving updates from the server.\n * - `onError` - Called whenever an error occurs during the lifecycle of the managed subscription.\n */\nexport function useSubscription(\n  criteria: string | undefined,\n  callback: (bundle: Bundle) => void,\n  options?: UseSubscriptionOptions\n): void {\n  const medplum = useMedplum();\n  const [emitter, setEmitter] = useState<SubscriptionEmitter>();\n  // We don't memoize the entire options object since it contains callbacks and if the callbacks change identity, we don't want to trigger a resubscribe to criteria\n  const [memoizedSubProps, setMemoizedSubProps] = useState(options?.subscriptionProps);\n\n  const listeningRef = useRef(false);\n  const unsubTimerRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const prevCriteriaRef = useRef<string | undefined>();\n  const prevMemoizedSubPropsRef = useRef<UseSubscriptionOptions['subscriptionProps']>();\n\n  const callbackRef = useRef<typeof callback>();\n  callbackRef.current = callback;\n\n  const onWebSocketOpenRef = useRef<UseSubscriptionOptions['onWebSocketOpen']>();\n  onWebSocketOpenRef.current = options?.onWebSocketOpen;\n\n  const onWebSocketCloseRef = useRef<UseSubscriptionOptions['onWebSocketClose']>();\n  onWebSocketCloseRef.current = options?.onWebSocketClose;\n\n  const onSubscriptionConnectRef = useRef<UseSubscriptionOptions['onSubscriptionConnect']>();\n  onSubscriptionConnectRef.current = options?.onSubscriptionConnect;\n\n  const onSubscriptionDisconnectRef = useRef<UseSubscriptionOptions['onSubscriptionDisconnect']>();\n  onSubscriptionDisconnectRef.current = options?.onSubscriptionDisconnect;\n\n  const onErrorRef = useRef<UseSubscriptionOptions['onError']>();\n  onErrorRef.current = options?.onError;\n\n  useEffect(() => {\n    // Deep equals checks referential equality first\n    if (!deepEquals(options?.subscriptionProps, memoizedSubProps)) {\n      setMemoizedSubProps(options?.subscriptionProps);\n    }\n  }, [memoizedSubProps, options]);\n\n  useEffect(() => {\n    if (unsubTimerRef.current) {\n      clearTimeout(unsubTimerRef.current);\n      unsubTimerRef.current = undefined;\n    }\n\n    let shouldSubscribe = false;\n    if (prevCriteriaRef.current !== criteria || !deepEquals(prevMemoizedSubPropsRef.current, memoizedSubProps)) {\n      shouldSubscribe = true;\n    }\n\n    if (shouldSubscribe && prevCriteriaRef.current) {\n      medplum.unsubscribeFromCriteria(prevCriteriaRef.current, prevMemoizedSubPropsRef.current);\n    }\n\n    // Set prev criteria and options to latest after checking them\n    prevCriteriaRef.current = criteria;\n    prevMemoizedSubPropsRef.current = memoizedSubProps;\n\n    // We do this after as to not immediately trigger re-render\n    if (shouldSubscribe && criteria) {\n      setEmitter(medplum.subscribeToCriteria(criteria, memoizedSubProps));\n    } else if (!criteria) {\n      setEmitter(undefined);\n    }\n\n    return () => {\n      unsubTimerRef.current = setTimeout(() => {\n        setEmitter(undefined);\n        if (criteria) {\n          medplum.unsubscribeFromCriteria(criteria, memoizedSubProps);\n        }\n      }, SUBSCRIPTION_DEBOUNCE_MS);\n    };\n  }, [medplum, criteria, memoizedSubProps]);\n\n  const emitterCallback = useCallback((event: SubscriptionEventMap['message']) => {\n    callbackRef.current?.(event.payload);\n  }, []);\n\n  const onWebSocketOpen = useCallback(() => {\n    onWebSocketOpenRef.current?.();\n  }, []);\n\n  const onWebSocketClose = useCallback(() => {\n    onWebSocketCloseRef.current?.();\n  }, []);\n\n  const onSubscriptionConnect = useCallback((event: SubscriptionEventMap['connect']) => {\n    onSubscriptionConnectRef.current?.(event.payload.subscriptionId);\n  }, []);\n\n  const onSubscriptionDisconnect = useCallback((event: SubscriptionEventMap['disconnect']) => {\n    onSubscriptionDisconnectRef.current?.(event.payload.subscriptionId);\n  }, []);\n\n  const onError = useCallback((event: SubscriptionEventMap['error']) => {\n    onErrorRef.current?.(event.payload);\n  }, []);\n\n  useEffect(() => {\n    if (!emitter) {\n      return () => undefined;\n    }\n    if (!listeningRef.current) {\n      emitter.addEventListener('message', emitterCallback);\n      emitter.addEventListener('open', onWebSocketOpen);\n      emitter.addEventListener('close', onWebSocketClose);\n      emitter.addEventListener('connect', onSubscriptionConnect);\n      emitter.addEventListener('disconnect', onSubscriptionDisconnect);\n      emitter.addEventListener('error', onError);\n      listeningRef.current = true;\n    }\n    return () => {\n      listeningRef.current = false;\n      emitter.removeEventListener('message', emitterCallback);\n      emitter.removeEventListener('open', onWebSocketOpen);\n      emitter.removeEventListener('close', onWebSocketClose);\n      emitter.removeEventListener('connect', onSubscriptionConnect);\n      emitter.removeEventListener('disconnect', onSubscriptionDisconnect);\n      emitter.removeEventListener('error', onError);\n    };\n  }, [\n    emitter,\n    emitterCallback,\n    onWebSocketOpen,\n    onWebSocketClose,\n    onSubscriptionConnect,\n    onSubscriptionDisconnect,\n    onError,\n  ]);\n}\n"],
  "mappings": "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",
  "names": ["useEffect", "useMemo", "useState", "createContext", "useContext", "reactContext", "useMedplumContext", "useMedplum", "useMedplumNavigate", "useMedplumProfile", "jsx", "EVENTS_TO_TRACK", "MedplumProvider", "props", "medplum", "navigate", "defaultNavigate", "state", "setState", "useState", "useEffect", "eventListener", "s", "event", "medplumContext", "useMemo", "reactContext", "path", "useMemo", "urls", "useCachedBinaryUrl", "binaryUrl", "binaryResourceUrl", "binaryUrlSearchParams", "binaryUrlExpires", "cachedUrl", "expires", "useEffect", "useRef", "usePrevious", "value", "ref", "deepEquals", "isReference", "isResource", "normalizeOperationOutcome", "useCallback", "useEffect", "useState", "useResource", "value", "setOutcome", "medplum", "useMedplum", "resource", "setResource", "useState", "getInitialResource", "setResourceIfChanged", "useCallback", "r", "deepEquals", "useEffect", "subscribed", "newValue", "isReference", "err", "normalizeOperationOutcome", "isResource", "allOk", "normalizeOperationOutcome", "useEffect", "useState", "useCallback", "useEffect", "useRef", "useState", "useDebouncedValue", "value", "waitMs", "options", "debouncedValue", "setDebouncedValue", "mountedRef", "timeoutRef", "cooldownRef", "cancel", "DEFAULT_DEBOUNCE_MS", "useSearch", "resourceType", "query", "options", "useSearchImpl", "useSearchOne", "useSearchResources", "searchFn", "medplum", "useMedplum", "lastSearchKey", "setLastSearchKey", "useState", "loading", "setLoading", "result", "setResult", "outcome", "setOutcome", "searchKey", "debouncedSearchKey", "useDebouncedValue", "useEffect", "res", "allOk", "err", "normalizeOperationOutcome", "deepEquals", "useCallback", "useEffect", "useRef", "useState", "SUBSCRIPTION_DEBOUNCE_MS", "useSubscription", "criteria", "callback", "options", "medplum", "useMedplum", "emitter", "setEmitter", "useState", "memoizedSubProps", "setMemoizedSubProps", "listeningRef", "useRef", "unsubTimerRef", "prevCriteriaRef", "prevMemoizedSubPropsRef", "callbackRef", "onWebSocketOpenRef", "onWebSocketCloseRef", "onSubscriptionConnectRef", "onSubscriptionDisconnectRef", "onErrorRef", "useEffect", "deepEquals", "shouldSubscribe", "emitterCallback", "useCallback", "event", "onWebSocketOpen", "onWebSocketClose", "onSubscriptionConnect", "onSubscriptionDisconnect", "onError"]
}
