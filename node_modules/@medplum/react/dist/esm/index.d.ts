import { AccessPolicyResource } from '@medplum/fhirtypes';
import { Address } from '@medplum/fhirtypes';
import { AnchorProps } from '@mantine/core';
import { Annotation } from '@medplum/fhirtypes';
import { Attachment } from '@medplum/fhirtypes';
import { AvatarProps } from '@mantine/core';
import { BaseLoginRequest } from '@medplum/core';
import { Bundle } from '@medplum/fhirtypes';
import { CardProps } from '@mantine/core';
import { ClientApplication } from '@medplum/fhirtypes';
import { CodeableConcept } from '@medplum/fhirtypes';
import { Coding } from '@medplum/fhirtypes';
import { ComboboxItem } from '@mantine/core';
import { ComboboxProps } from '@mantine/core';
import { Communication } from '@medplum/fhirtypes';
import { Component } from 'react';
import { ContactDetail } from '@medplum/fhirtypes';
import { ContactPoint } from '@medplum/fhirtypes';
import { ContainerProps } from '@mantine/core';
import { Context } from 'react';
import { CSSProperties } from 'react';
import { DiagnosticReport } from '@medplum/fhirtypes';
import { ElementDefinitionBinding } from '@medplum/fhirtypes';
import { ElementDefinitionType } from '@medplum/fhirtypes';
import { Encounter } from '@medplum/fhirtypes';
import { ErrorInfo } from 'react';
import { ExtendedInternalSchemaElement } from '@medplum/core';
import { ExtractResource } from '@medplum/fhirtypes';
import { Filter } from '@medplum/core';
import { HumanName } from '@medplum/fhirtypes';
import { HumanNameFormatOptions } from '@medplum/core';
import { Identifier } from '@medplum/fhirtypes';
import { InternalSchemaElement } from '@medplum/core';
import { MeasureReport } from '@medplum/fhirtypes';
import { Media } from '@medplum/fhirtypes';
import { MedplumClient } from '@medplum/core';
import { MemoExoticComponent } from 'react';
import { Money } from '@medplum/fhirtypes';
import { MouseEvent as MouseEvent_2 } from 'react';
import { MouseEventHandler } from 'react';
import { Observation } from '@medplum/fhirtypes';
import { ObservationDefinition } from '@medplum/fhirtypes';
import { ObservationDefinitionQualifiedInterval } from '@medplum/fhirtypes';
import { OperationOutcome } from '@medplum/fhirtypes';
import { OperationOutcomeIssue } from '@medplum/fhirtypes';
import { Operator } from '@medplum/core';
import { PaperProps } from '@mantine/core';
import { Patient } from '@medplum/fhirtypes';
import { PlanDefinition } from '@medplum/fhirtypes';
import { ProfileResource } from '@medplum/core';
import { Quantity } from '@medplum/fhirtypes';
import { QueryTypes } from '@medplum/core';
import { Questionnaire } from '@medplum/fhirtypes';
import { QuestionnaireItem } from '@medplum/fhirtypes';
import { QuestionnaireItemAnswerOption } from '@medplum/fhirtypes';
import { QuestionnaireItemEnableWhen } from '@medplum/fhirtypes';
import { QuestionnaireItemInitial } from '@medplum/fhirtypes';
import { QuestionnaireResponse } from '@medplum/fhirtypes';
import { QuestionnaireResponseItem } from '@medplum/fhirtypes';
import { QuestionnaireResponseItemAnswer } from '@medplum/fhirtypes';
import { Range as Range_2 } from '@medplum/fhirtypes';
import { Ratio } from '@medplum/fhirtypes';
import { ReactNode } from 'react';
import { Reference } from '@medplum/fhirtypes';
import { RequestGroup } from '@medplum/fhirtypes';
import { Resource } from '@medplum/fhirtypes';
import { ResourceArray } from '@medplum/core';
import { ResourceType } from '@medplum/fhirtypes';
import { Schedule } from '@medplum/fhirtypes';
import { SearchParameter } from '@medplum/fhirtypes';
import { SearchRequest } from '@medplum/core';
import { ServiceRequest } from '@medplum/fhirtypes';
import { Slot } from '@medplum/fhirtypes';
import { StructureDefinition } from '@medplum/fhirtypes';
import { Subscription } from '@medplum/fhirtypes';
import { Task } from '@medplum/fhirtypes';
import { TextProps } from '@mantine/core';
import { Timing } from '@medplum/fhirtypes';
import { TypedValue } from '@medplum/core';
import { ValueSetExpandParams } from '@medplum/core';
import { ValueSetExpansionContains } from '@medplum/fhirtypes';

/**
 * Adds a filter for a date between two dates (inclusive of both dates).
 * @param definition - The original search request.
 * @param field - The field key name.
 * @param d1 - The start date.
 * @param d2 - The end date.
 * @returns The updated search request.
 */
export declare function addDateFilterBetween(definition: SearchRequest, field: string, d1: Date, d2: Date): SearchRequest;

/**
 * Adds a field.
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addField(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter.
 * @param definition - The original search request.
 * @param field - The field key name.
 * @param op - The operation key name.
 * @param value - The filter value.
 * @param opt_clear - Optional flag to clear filters on the field.
 * @returns The updated search request.
 */
export declare function addFilter(definition: SearchRequest, field: string, op: Operator, value?: string, opt_clear?: boolean): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "last month".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addLastMonthFilter(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "missing".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @param value - Optional boolean value. Default is true.
 * @returns The updated search request.
 */
export declare function addMissingFilter(definition: SearchRequest, field: string, value?: boolean): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "next month".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addNextMonthFilter(definition: SearchRequest, field: string): SearchRequest;

export declare function AddressDisplay(props: AddressDisplayProps): JSX.Element | null;

export declare interface AddressDisplayProps {
    readonly value?: Address;
}

export declare function AddressInput(props: AddressInputProps): JSX.Element;

export declare type AddressInputProps = ComplexTypeInputProps<Address>;

/**
 * Adds a filter that constrains the specified field to "this month".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addThisMonthFilter(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "today".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addTodayFilter(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "tomorrow".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addTomorrowFilter(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter that constrains the specified field to the year to date.
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addYearToDateFilter(definition: SearchRequest, field: string): SearchRequest;

/**
 * Adds a filter that constrains the specified field to "yesterday".
 * @param definition - The original search request.
 * @param field - The field key name.
 * @returns The updated search request.
 */
export declare function addYesterdayFilter(definition: SearchRequest, field: string): SearchRequest;

export declare function AnnotationInput(props: AnnotationInputProps): JSX.Element;

export declare interface AnnotationInputProps extends ComplexTypeInputProps<Annotation> {
}

export declare function AppShell(props: AppShellProps): JSX.Element;

export declare interface AppShellProps {
    readonly logo: ReactNode;
    readonly pathname?: string;
    readonly searchParams?: URLSearchParams;
    readonly headerSearchDisabled?: boolean;
    readonly version?: string;
    readonly menus?: NavbarMenu[];
    readonly children: ReactNode;
    readonly displayAddBookmark?: boolean;
    readonly resourceTypeSearchDisabled?: boolean;
    readonly notifications?: ReactNode;
}

export declare function AsyncAutocomplete<T>(props: AsyncAutocompleteProps<T>): JSX.Element;

export declare interface AsyncAutocompleteOption<T> extends ComboboxItem {
    readonly active?: boolean;
    readonly resource: T;
}

export declare interface AsyncAutocompleteProps<T> extends Omit<ComboboxProps, 'data' | 'defaultValue' | 'loadOptions' | 'onChange' | 'onCreate' | 'searchable'> {
    readonly name?: string;
    readonly label?: ReactNode;
    readonly description?: ReactNode;
    readonly error?: ReactNode;
    readonly defaultValue?: T | T[];
    readonly toOption: (item: T) => AsyncAutocompleteOption<T>;
    readonly loadOptions: (input: string, signal: AbortSignal) => Promise<T[]>;
    readonly itemComponent?: (props: AsyncAutocompleteOption<T>) => JSX.Element | ReactNode;
    readonly pillComponent?: (props: {
        item: AsyncAutocompleteOption<T>;
        disabled?: boolean;
        onRemove: () => void;
    }) => JSX.Element;
    readonly emptyComponent?: (props: {
        search: string;
    }) => JSX.Element | ReactNode;
    readonly onChange: (item: T[]) => void;
    readonly onCreate?: (input: string) => T;
    readonly creatable?: boolean;
    readonly clearable?: boolean;
    readonly required?: boolean;
    readonly className?: string;
    readonly placeholder?: string;
    readonly leftSection?: ReactNode;
    readonly maxValues?: number;
    readonly optionsDropdownMaxHeight?: number;
    readonly minInputLength?: number;
}

export declare function AttachmentArrayDisplay(props: AttachmentArrayDisplayProps): JSX.Element;

export declare interface AttachmentArrayDisplayProps {
    readonly path?: string;
    readonly values?: Attachment[];
    readonly maxWidth?: number;
    readonly includeDescriptionListEntry?: boolean;
    readonly property?: InternalSchemaElement;
}

export declare function AttachmentArrayInput(props: AttachmentArrayInputProps): JSX.Element;

export declare interface AttachmentArrayInputProps {
    readonly name: string;
    readonly defaultValue?: Attachment[];
    readonly arrayElement?: boolean;
    readonly onChange?: (value: Attachment[]) => void;
    readonly disabled?: boolean;
}

export declare function AttachmentButton(props: AttachmentButtonProps): JSX.Element;

export declare interface AttachmentButtonProps {
    readonly securityContext?: Reference;
    readonly onUpload: (attachment: Attachment) => void;
    readonly onUploadStart?: () => void;
    readonly onUploadProgress?: (e: ProgressEvent) => void;
    readonly onUploadError?: (outcome: OperationOutcome) => void;
    children(props: {
        disabled?: boolean;
        onClick(e: MouseEvent_2): void;
    }): ReactNode;
    readonly disabled?: boolean;
}

export declare function AttachmentDisplay(props: AttachmentDisplayProps): JSX.Element | null;

export declare interface AttachmentDisplayProps {
    readonly value?: Attachment;
    readonly maxWidth?: number;
}

export declare function AttachmentInput(props: AttachmentInputProps): JSX.Element;

export declare interface AttachmentInputProps extends ComplexTypeInputProps<Attachment> {
    readonly arrayElement?: boolean;
    readonly securityContext?: Reference;
    readonly onChange?: (value: Attachment | undefined) => void;
}

export declare function BackboneElementDisplay(props: BackboneElementDisplayProps): JSX.Element | null;

export declare interface BackboneElementDisplayProps {
    readonly value: TypedValue;
    /** The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension. */
    readonly path: string;
    readonly compact?: boolean;
    readonly ignoreMissingValues?: boolean;
    readonly link?: boolean;
    /** (optional) Profile URL of the structure definition represented by the backbone element */
    readonly profileUrl?: string;
    /**
     * (optional) If provided, inputs specified in `accessPolicyResource.hiddenFields` are not shown.
     */
    readonly accessPolicyResource?: AccessPolicyResource;
}

export declare function BackboneElementInput(props: BackboneElementInputProps): JSX.Element;

export declare interface BackboneElementInputProps extends BaseInputProps {
    /** Type name the backbone element represents */
    readonly typeName: string;
    /** (optional) The contents of the resource represented by the backbone element */
    readonly defaultValue?: any;
    /** (optional) callback function that is called when the value of the backbone element changes */
    readonly onChange?: (value: any) => void;
    /** (optional) Profile URL of the structure definition represented by the backbone element */
    readonly profileUrl?: string;
    /**
     * (optional) If provided, inputs specified in `accessPolicyResource.readonlyFields` are not editable
     * and inputs specified in `accessPolicyResource.hiddenFields` are not shown.
     */
    readonly accessPolicyResource?: AccessPolicyResource;
}

export declare function BaseChat(props: BaseChatProps): JSX.Element | null;

export declare interface BaseChatProps extends PaperProps {
    readonly title: string;
    readonly communications: Communication[];
    readonly setCommunications: (communications: Communication[]) => void;
    readonly query: string;
    readonly sendMessage: (content: string) => void;
    readonly onMessageReceived?: (message: Communication) => void;
    readonly onMessageUpdated?: (message: Communication) => void;
    readonly inputDisabled?: boolean;
    readonly onError?: (err: Error) => void;
}

export declare interface BaseInputProps {
    /** The path identifying the related element definition and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension. */
    readonly path: string;
    /** (optional) A FHIRPath expression that identifies the input more precisely than `path`, e.g. `Patient.identifier[0].system` versus `Patient.identifier.system` */
    readonly valuePath?: string;
    /** (optional) OperationOutcome from the last attempted system action*/
    readonly outcome?: OperationOutcome;
}

/**
 * Returns a field display name.
 * @param key - The field key.
 * @returns The field display name.
 */
export declare function buildFieldNameString(key: string): string;

export declare function buildInitialResponse(questionnaire: Questionnaire): QuestionnaireResponse;

export declare function buildInitialResponseItem(item: QuestionnaireItem): QuestionnaireResponseItem;

export declare function CalendarInput(props: CalendarInputProps): JSX.Element;

export declare interface CalendarInputProps {
    readonly slots: Slot[];
    readonly onChangeMonth: (date: Date) => void;
    readonly onClick: (date: Date) => void;
}

export declare interface ChatBubbleSkeletonProps {
    readonly alignment: 'left' | 'right';
    readonly parentWidth: number;
}

export declare function ChatModal(props: ChatModalProps): JSX.Element | null;

export declare interface ChatModalProps {
    readonly open?: boolean;
    readonly children: ReactNode;
}

export declare function CheckboxFormSection(props: CheckboxFormSectionProps): JSX.Element;

export declare interface CheckboxFormSectionProps {
    readonly htmlFor?: string;
    readonly title?: string;
    readonly description?: string;
    readonly withAsterisk?: boolean;
    readonly children?: ReactNode;
    readonly testId?: string;
    readonly fhirPath?: string;
    readonly readonly?: boolean;
}

/**
 * Clears all of the filters.
 * @param definition - The original search request.
 * @returns The updated search request.
 */
export declare function clearFilters(definition: SearchRequest): SearchRequest;

/**
 * Clears all of the filters on a certain field.
 * @param definition - The original search request.
 * @param code - The field key name to clear filters.
 * @returns The updated search request.
 */
export declare function clearFiltersOnField(definition: SearchRequest, code: string): SearchRequest;

export declare function CodeableConceptDisplay(props: CodeableConceptDisplayProps): JSX.Element;

export declare interface CodeableConceptDisplayProps {
    readonly value?: CodeableConcept;
}

export declare function CodeableConceptInput(props: CodeableConceptInputProps): JSX.Element;

export declare interface CodeableConceptInputProps extends Omit<ValueSetAutocompleteProps, 'name' | 'defaultValue' | 'onChange' | 'disabled'>, ComplexTypeInputProps<CodeableConcept> {
    readonly onChange?: (value: CodeableConcept | undefined) => void;
}

export declare function CodeInput(props: CodeInputProps): JSX.Element;

export declare interface CodeInputProps extends Omit<ValueSetAutocompleteProps, 'defaultValue' | 'onChange'> {
    readonly defaultValue?: string;
    readonly onChange: ((value: string | undefined) => void) | undefined;
}

export declare function CodingDisplay(props: CodingDisplayProps): JSX.Element;

export declare interface CodingDisplayProps {
    readonly value?: Coding;
}

export declare function CodingInput(props: CodingInputProps): JSX.Element;

export declare interface CodingInputProps extends Omit<ValueSetAutocompleteProps, 'defaultValue' | 'onChange' | 'disabled' | 'name'>, ComplexTypeInputProps<Coding> {
}

export declare interface ComplexTypeInputProps<ValueType> extends BaseInputProps {
    readonly name: string;
    readonly defaultValue?: ValueType;
    readonly onChange?: (value: ValueType, propName?: string) => void;
    readonly disabled?: boolean;
}

export declare function ContactDetailDisplay(props: ContactDetailDisplayProps): JSX.Element | null;

export declare interface ContactDetailDisplayProps {
    readonly value?: ContactDetail;
}

export declare function ContactDetailInput(props: ContactDetailInputProps): JSX.Element;

export declare type ContactDetailInputProps = ComplexTypeInputProps<ContactDetail>;

export declare function ContactPointDisplay(props: ContactPointDisplayProps): JSX.Element | null;

export declare interface ContactPointDisplayProps {
    readonly value?: ContactPoint;
}

export declare function ContactPointInput(props: ContactPointInputProps): JSX.Element;

export declare type ContactPointInputProps = ComplexTypeInputProps<ContactPoint> & {
    readonly onChange?: (value: ContactPoint | undefined) => void;
};

export declare function Container(props: ContainerProps): JSX.Element;

/**
 * Converts an ISO-8601 date/time string to a local date/time string.
 * @param isoString - The ISO-8601 date/time string to convert.
 * @returns The local date/time string.
 */
export declare function convertIsoToLocal(isoString: string | undefined): string;

/**
 * Converts a local date/time string to an ISO-8601 date/time string.
 * @param localString - The local date/time string to convert.
 * @returns The ISO-8601 date/time string.
 */
export declare function convertLocalToIso(localString: string | undefined): string;

/**
 * Dynamically creates a script tag for the specified JavaScript file.
 * @param src - The JavaScript file URL.
 * @param onload - Optional callback for the onload event.
 */
export declare function createScriptTag(src: string, onload?: () => void): void;

/**
 * The DateTimeInput component is a wrapper around the HTML5 input type="datetime-local".
 * The main purpose is to reconcile time zones.
 * Most of our date/time values are in ISO-8601, which includes a time zone offset.
 * The datetime-local input does not support the time zone offset.
 * @param props - The Input props.
 * @returns The JSX element to render.
 */
export declare function DateTimeInput(props: DateTimeInputProps): JSX.Element;

export declare interface DateTimeInputProps extends PrimitiveTypeInputProps {
    readonly label?: string;
    readonly placeholder?: string;
    readonly defaultValue?: string;
    readonly autoFocus?: boolean;
    readonly outcome?: OperationOutcome;
    readonly onChange?: (value: string) => void;
}

export declare function DefaultResourceTimeline(props: DefaultResourceTimelineProps): JSX.Element;

export declare interface DefaultResourceTimelineProps extends Pick<ResourceTimelineProps<Resource>, 'getMenu'> {
    readonly resource: Resource | Reference;
}

/**
 * Deletes a filter at the specified index.
 * @param definition - The original search request.
 * @param index - The filter index.
 * @returns The updated search request.
 */
export declare function deleteFilter(definition: SearchRequest, index: number): SearchRequest;

export declare function DescriptionList(props: DescriptionListProps): JSX.Element;

export declare function DescriptionListEntry(props: DescriptionListEntryProps): JSX.Element;

export declare interface DescriptionListEntryProps {
    readonly term: string;
    readonly children: ReactNode;
}

export declare interface DescriptionListProps {
    readonly children: ReactNode;
    readonly compact?: boolean;
}

export declare function DiagnosticReportDisplay(props: DiagnosticReportDisplayProps): JSX.Element | null;

export declare namespace DiagnosticReportDisplay {
    var defaultProps: DiagnosticReportDisplayProps;
}

export declare interface DiagnosticReportDisplayProps {
    readonly value?: DiagnosticReport | Reference<DiagnosticReport>;
    readonly hideObservationNotes?: boolean;
    readonly hideSpecimenInfo?: boolean;
}

declare function Document_2(props: PanelProps): JSX.Element;
export { Document_2 as Document }

export declare function ElementDefinitionInputSelector(props: ElementDefinitionSelectorProps): JSX.Element;

export declare interface ElementDefinitionSelectorProps extends ResourcePropertyInputProps {
    readonly elementDefinitionTypes: ElementDefinitionType[];
}

export declare function ElementDefinitionTypeInput(props: ElementDefinitionTypeInputProps): JSX.Element;

export declare interface ElementDefinitionTypeInputProps extends Pick<ResourcePropertyInputProps, 'name' | 'path' | 'valuePath' | 'defaultValue' | 'onChange' | 'outcome'> {
    readonly elementDefinitionType: ElementDefinitionType;
    readonly min: number;
    readonly max: number;
    readonly binding: ElementDefinitionBinding | undefined;
    readonly readOnly?: boolean;
}

export declare function EncounterTimeline(props: EncounterTimelineProps): JSX.Element;

export declare interface EncounterTimelineProps extends Pick<ResourceTimelineProps<Encounter>, 'getMenu'> {
    readonly encounter: Encounter | Reference<Encounter>;
}

/**
 * ErrorBoundary is a React component that handles errors in its child components.
 * See: https://reactjs.org/docs/error-boundaries.html
 */
export declare class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
    readonly state: ErrorBoundaryState;
    constructor(props: ErrorBoundaryProps);
    static getDerivedStateFromError(error: Error): ErrorBoundaryState;
    componentDidUpdate(_prevProps: ErrorBoundaryProps, _prevState: ErrorBoundaryState): void;
    shouldComponentUpdate(nextProps: ErrorBoundaryProps, nextState: ErrorBoundaryState): boolean;
    componentDidCatch(error: Error, errorInfo: ErrorInfo): void;
    render(): ReactNode;
}

export declare interface ErrorBoundaryProps {
    readonly children: ReactNode;
}

export declare interface ErrorBoundaryState {
    readonly error?: Error;
    readonly lastLocation: string;
}

/**
 * The FhirPathTable component represents the embeddable search table control.
 * @param props - FhirPathTable React props.
 * @returns FhirPathTable React node.
 */
export declare function FhirPathTable(props: FhirPathTableProps): JSX.Element;

export declare interface FhirPathTableField {
    readonly propertyType: string;
    readonly name: string;
    readonly fhirPath: string;
}

export declare interface FhirPathTableProps {
    readonly resourceType: string;
    readonly query: string;
    readonly fields: FhirPathTableField[];
    readonly checkboxesEnabled?: boolean;
    readonly onClick?: (e: SearchClickEvent) => void;
    readonly onAuxClick?: (e: SearchClickEvent) => void;
    readonly onBulk?: (ids: string[]) => void;
}

export declare function Form(props: FormProps): JSX.Element;

export declare function formatReferenceString(typedValue: TypedValue): string;

export declare interface FormProps {
    readonly onSubmit?: (formData: Record<string, string>) => void;
    readonly style?: CSSProperties;
    readonly children?: ReactNode;
    readonly testid?: string;
}

export declare function FormSection(props: FormSectionProps): JSX.Element;

export declare interface FormSectionProps {
    readonly title?: string;
    readonly htmlFor?: string;
    readonly description?: string;
    readonly withAsterisk?: boolean;
    readonly outcome?: OperationOutcome;
    readonly children?: ReactNode;
    readonly testId?: string;
    readonly fhirPath?: string;
    readonly errorExpression?: string;
    readonly readonly?: boolean;
}

export declare function getErrorsForInput(outcome: OperationOutcome | undefined, expression: string | undefined): string | undefined;

/**
 * Returns the collection of field definitions for the search request.
 * @param search - The search request definition.
 * @returns An array of field definitions.
 */
export declare function getFieldDefinitions(search: SearchRequest): SearchControlField[];

export declare function getIssuesForExpression(outcome: OperationOutcome | undefined, expression: string | undefined): OperationOutcomeIssue[] | undefined;

export declare function getItemAnswerOptionValue(option: QuestionnaireItemAnswerOption): TypedValue;

export declare function getItemEnableWhenValueAnswer(enableWhen: QuestionnaireItemEnableWhen): TypedValue;

export declare function getItemInitialValue(initial: QuestionnaireItemInitial | undefined): TypedValue;

export declare function getNewMultiSelectValues(selected: string[], propertyName: string, item: QuestionnaireItem): QuestionnaireResponseItemAnswer[];

/**
 * Returns the number of pages in the questionnaire.
 *
 * By default, a questionnaire is represented as a simple single page questionnaire,
 * so the default return value is 1.
 *
 * If the questionnaire has a page extension on the first item, then the number of pages
 * is the number of top level items in the questionnaire.
 *
 * @param questionnaire - The questionnaire to get the number of pages for.
 * @returns The number of pages in the questionnaire. Default is 1.
 */
export declare function getNumberOfPages(questionnaire: Questionnaire): number;

/**
 * Returns a string representing the operation.
 * @param op - The operation code.
 * @returns A display string for the operation.
 */
export declare function getOpString(op: Operator): string;

/**
 * Returns the reference filter for the given questionnaire item.
 * @see https://build.fhir.org/ig/HL7/fhir-extensions//StructureDefinition-questionnaire-referenceFilter-definitions.html
 * @param item - The questionnaire item to get the reference filter for.
 * @param subject - Optional subject reference.
 * @param encounter - Optional encounter reference.
 * @returns The reference filter as a map of key/value pairs.
 */
export declare function getQuestionnaireItemReferenceFilter(item: QuestionnaireItem, subject: Reference | undefined, encounter: Reference<Encounter> | undefined): Record<string, string> | undefined;

export declare function getQuestionnaireItemReferenceTargetTypes(item: QuestionnaireItem): ResourceType[] | undefined;

/**
 * Starts a request to generate a recapcha token.
 * @param siteKey - The reCAPTCHA site key, available from the reCAPTCHA admin page.
 * @returns Promise to a recaptcha token for the current user.
 */
export declare function getRecaptcha(siteKey: string): Promise<string>;

export declare function getResponseItemAnswerValue(answer: QuestionnaireResponseItemAnswer): TypedValue | undefined;

/**
 * Returns a list of operators for a search parameter.
 * @param searchParam - The search parameter.
 * @returns The list of operators that can be used for the search parameter.
 */
export declare function getSearchOperators(searchParam: SearchParameter): Operator[] | undefined;

export declare function getSortField(definition: SearchRequest): string | undefined;

export declare function getValuePath(elementPath: string, valuePath: string | undefined, arrayIndex?: number): string;

export declare function Header(props: HeaderProps): JSX.Element;

export declare interface HeaderProps {
    readonly pathname?: string;
    readonly searchParams?: URLSearchParams;
    readonly headerSearchDisabled?: boolean;
    readonly logo: ReactNode;
    readonly version?: string;
    readonly navbarToggle: () => void;
    readonly notifications?: ReactNode;
}

export declare function HumanNameDisplay(props: HumanNameDisplayProps): JSX.Element | null;

export declare interface HumanNameDisplayProps {
    readonly value?: HumanName;
    readonly options?: HumanNameFormatOptions;
}

export declare function HumanNameInput(props: HumanNameInputProps): JSX.Element;

export declare type HumanNameInputProps = ComplexTypeInputProps<HumanName>;

export declare function IdentifierDisplay(props: IdentifierDisplayProps): JSX.Element;

export declare interface IdentifierDisplayProps {
    readonly value?: Identifier;
}

export declare function IdentifierInput(props: IdentifierInputProps): JSX.Element;

export declare type IdentifierInputProps = ComplexTypeInputProps<Identifier>;

/**
 * Dynamically loads the recaptcha script.
 * We do not want to load the script on page load unless the user needs it.
 * @param siteKey - The reCAPTCHA site key, available from the reCAPTCHA admin page.
 */
export declare function initRecaptcha(siteKey: string): void;

export declare type IntervalGroup = {
    id: string;
    filters: Record<string, any>;
    intervals: ObservationDefinitionQualifiedInterval[];
};

export declare function isChoiceQuestion(item: QuestionnaireItem): boolean;

export declare function isQuestionEnabled(item: QuestionnaireItem, questionnaireResponse: QuestionnaireResponse | undefined): boolean;

export declare function isSortDescending(definition: SearchRequest): boolean;

export declare function isSupportedProfileStructureDefinition(profile?: StructureDefinition): profile is SupportedProfileStructureDefinition;

export declare function Loading(): JSX.Element;

export declare function Logo(props: LogoProps): JSX.Element;

export declare interface LogoProps {
    readonly size: number;
    readonly fill?: string;
}

export declare function MeasureReportDisplay(props: MeasureReportDisplayProps): JSX.Element | null;

export declare interface MeasureReportDisplayProps {
    readonly measureReport: MeasureReport | Reference<MeasureReport>;
}

export declare interface MedplumContext {
    medplum: MedplumClient;
    navigate: MedplumNavigateFunction;
    profile?: ProfileResource;
    loading: boolean;
}

export declare function MedplumLink(props: MedplumLinkProps): JSX.Element;

export declare interface MedplumLinkProps extends TextProps {
    readonly to?: Resource | Reference | string;
    readonly suffix?: string;
    readonly label?: string;
    readonly onClick?: MouseEventHandler;
    readonly children: ReactNode;
}

export declare type MedplumNavigateFunction = (path: string) => void;

/**
 * The MedplumProvider component provides Medplum context state.
 *
 * Medplum context includes:
 *   1) medplum - Medplum client library
 *   2) profile - The current user profile (if signed in)
 * @param props - The MedplumProvider React props.
 * @returns The MedplumProvider React node.
 */
export declare function MedplumProvider(props: MedplumProviderProps): JSX.Element;

export declare interface MedplumProviderProps {
    readonly medplum: MedplumClient;
    readonly navigate?: MedplumNavigateFunction;
    readonly children: ReactNode;
}

export declare const MemoizedFhirPathTable: MemoExoticComponent<typeof FhirPathTable>;

/**
 * @deprecated
 *
 * The memoization `MemoizedSearchControl` provides has been merged into `SearchControl`. Previously the memoization was done via HOC but
 * it was proven that this wasn't effective for a large number of use cases, especially when:
 * 1. `search` was an inline static object, which would trigger the memo to recompute on every re-render of the parent component
 * 2. Any of the callbacks, such as `onClick` were not memoized via `useCallback`, which would result in the recomputation as well
 *
 * Scenario 1 also retriggered the effect that runs `loadResults` on change of the `search`, which was less than desirable.
 *
 * The memoization is now accomplished via checking deep equality of the incoming `search` prop in the body of the component, and setting a memoized
 * state whenever the incoming and current memoized value are not deeply equal. See: https://github.com/medplum/medplum/pull/5023
 */
export declare const MemoizedSearchControl: typeof SearchControl;

export declare function MoneyDisplay(props: MoneyDisplayProps): JSX.Element | null;

export declare interface MoneyDisplayProps {
    readonly value?: Money;
}

export declare function MoneyInput(props: MoneyInputProps): JSX.Element;

export declare interface MoneyInputProps extends ComplexTypeInputProps<Money> {
    readonly label?: string;
    readonly placeholder?: string;
}

export declare function Navbar(props: NavbarProps): JSX.Element;

export declare interface NavbarLink {
    readonly icon?: JSX.Element;
    readonly label?: string;
    readonly href: string;
}

export declare interface NavbarMenu {
    readonly title?: string;
    readonly links?: NavbarLink[];
}

export declare interface NavbarProps {
    readonly pathname?: string;
    readonly searchParams?: URLSearchParams;
    readonly menus?: NavbarMenu[];
    readonly closeNavbar: () => void;
    readonly displayAddBookmark?: boolean;
    readonly resourceTypeSearchDisabled?: boolean;
}

export declare function NoteDisplay({ value }: NoteDisplayProps): JSX.Element | null;

export declare interface NoteDisplayProps {
    readonly value?: Annotation[];
}

export declare function NotificationIcon(props: NotificationIconProps): JSX.Element;

export declare interface NotificationIconProps {
    readonly iconComponent: JSX.Element;
    readonly label: string;
    readonly resourceType: ResourceType;
    readonly countCriteria: string;
    readonly subscriptionCriteria: string;
    readonly onClick: () => void;
}

export declare function ObservationTable(props: ObservationTableProps): JSX.Element;

export declare interface ObservationTableProps {
    readonly value?: Observation[] | Reference<Observation>[];
    readonly ancestorIds?: string[];
    readonly hideObservationNotes?: boolean;
}

export declare function OperationOutcomeAlert(props: OperationOutcomeAlertProps): JSX.Element | null;

export declare interface OperationOutcomeAlertProps {
    readonly outcome?: OperationOutcome;
    readonly issues?: OperationOutcomeIssue[];
}

export declare function Panel(props: PanelProps): JSX.Element;

export declare interface PanelProps extends PaperProps {
    readonly width?: number;
    readonly fill?: boolean;
    readonly children?: ReactNode;
}

/**
 * Parses an HTML form and returns the result as a JavaScript object.
 * @param form - The HTML form element.
 * @returns Form values in key value pairs.
 */
export declare function parseForm(form: HTMLFormElement): Record<string, string>;

export declare function PatientSummary(props: PatientSummaryProps): JSX.Element | null;

export declare interface PatientSummaryProps extends Omit<CardProps, 'children'> {
    readonly patient: Patient | Reference<Patient>;
    readonly background?: string;
    /** The URL that the upcoming appointments link should navigate to or `undefined` to not show the link. */
    readonly appointmentsUrl?: string | undefined;
    /** The URL that the documented visits (encounters) link should navigate to or `undefined` to not show the link. */
    readonly encountersUrl?: string | undefined;
}

export declare function PatientTimeline(props: PatientTimelineProps): JSX.Element;

export declare interface PatientTimelineProps extends Pick<ResourceTimelineProps<Patient>, 'getMenu'> {
    readonly patient: Patient | Reference<Patient>;
}

export declare function PlanDefinitionBuilder(props: PlanDefinitionBuilderProps): JSX.Element | null;

export declare interface PlanDefinitionBuilderProps {
    readonly value: Partial<PlanDefinition> | Reference<PlanDefinition>;
    readonly onSubmit: (result: PlanDefinition) => void;
}

export declare interface PrimitiveTypeInputProps {
    readonly id?: string;
    readonly name: string;
    readonly 'data-testid'?: string;
    readonly defaultValue?: any;
    readonly required?: boolean;
    readonly error?: string;
    readonly disabled?: boolean;
}

export declare function QuantityDisplay(props: QuantityDisplayProps): JSX.Element | null;

export declare interface QuantityDisplayProps {
    readonly value?: Quantity;
}

export declare function QuantityInput(props: QuantityInputProps): JSX.Element;

export declare interface QuantityInputProps extends ComplexTypeInputProps<Quantity> {
    readonly autoFocus?: boolean;
    readonly required?: boolean;
    readonly disableWheel?: boolean;
}

export declare function QuestionnaireBuilder(props: QuestionnaireBuilderProps): JSX.Element | null;

export declare interface QuestionnaireBuilderProps {
    readonly questionnaire: Partial<Questionnaire> | Reference<Questionnaire>;
    readonly onSubmit: (result: Questionnaire) => void;
    readonly autoSave?: boolean;
}

export declare function QuestionnaireForm(props: QuestionnaireFormProps): JSX.Element | null;

export declare const QuestionnaireFormContext: Context<    {
subject?: Reference;
encounter?: Reference<Encounter>;
}>;

export declare interface QuestionnaireFormProps {
    readonly questionnaire: Questionnaire | Reference<Questionnaire>;
    readonly subject?: Reference;
    readonly encounter?: Reference<Encounter>;
    readonly source?: QuestionnaireResponse['source'];
    readonly disablePagination?: boolean;
    readonly excludeButtons?: boolean;
    readonly submitButtonText?: string;
    readonly onChange?: (response: QuestionnaireResponse) => void;
    readonly onSubmit?: (response: QuestionnaireResponse) => void;
}

export declare enum QuestionnaireItemType {
    group = "group",
    display = "display",
    question = "question",
    boolean = "boolean",
    decimal = "decimal",
    integer = "integer",
    date = "date",
    dateTime = "dateTime",
    time = "time",
    string = "string",
    text = "text",
    url = "url",
    choice = "choice",
    openChoice = "open-choice",
    attachment = "attachment",
    reference = "reference",
    quantity = "quantity"
}

export declare function RangeDisplay(props: RangeDisplayProps): JSX.Element | null;

export declare interface RangeDisplayProps {
    readonly value?: Range_2;
}

/**
 * Renders a Range input.
 * See: https://www.hl7.org/fhir/datatypes.html#Range
 * @param props - Range input properties.
 * @returns Range input element.
 */
export declare function RangeInput(props: RangeInputProps): JSX.Element;

export declare interface RangeInputProps extends ComplexTypeInputProps<Range_2> {
}

/**
 * Renders a Ratio input.
 * See: https://www.hl7.org/fhir/datatypes.html#Ratio
 * @param props - Ratio input properties.
 * @returns Ratio input element.
 */
export declare function RatioInput(props: RatioInputProps): JSX.Element;

export declare interface RatioInputProps extends ComplexTypeInputProps<Ratio> {
}

export declare const reactContext: Context<MedplumContext | undefined>;

export declare function ReferenceDisplay(props: ReferenceDisplayProps): JSX.Element | null;

export declare interface ReferenceDisplayProps {
    readonly value?: Reference;
    readonly link?: boolean;
}

export declare function ReferenceInput(props: ReferenceInputProps): JSX.Element;

export declare interface ReferenceInputProps {
    readonly name: string;
    readonly placeholder?: string;
    readonly defaultValue?: Reference;
    readonly targetTypes?: string[];
    readonly searchCriteria?: Record<string, string>;
    readonly autoFocus?: boolean;
    readonly required?: boolean;
    readonly onChange?: (value: Reference | undefined) => void;
    readonly disabled?: boolean;
}

export declare function ReferenceRangeEditor(props: ReferenceRangeEditorProps): JSX.Element;

export declare interface ReferenceRangeEditorProps {
    readonly definition: ObservationDefinition;
    readonly onSubmit: (result: ObservationDefinition) => void;
}

export declare function ReferenceRangeGroupEditor(props: ReferenceRangeGroupEditorProps): JSX.Element;

/**
 * Helper component that renders an "interval group", which is a set of ObservationDefinitionQualifiedIntervals
 * that have the same filter values
 */
export declare interface ReferenceRangeGroupEditorProps {
    readonly intervalGroup: IntervalGroup;
    readonly unit: string | undefined;
    readonly onChange: (groupId: string, changed: ObservationDefinitionQualifiedInterval) => void;
    readonly onAdd: (groupId: string, added: ObservationDefinitionQualifiedInterval) => void;
    readonly onRemove: (groupId: string, removed: ObservationDefinitionQualifiedInterval) => void;
    readonly onRemoveGroup: (removedGroup: IntervalGroup) => void;
}

export declare function RegisterForm(props: RegisterFormProps): JSX.Element;

export declare interface RegisterFormProps {
    readonly type: 'patient' | 'project';
    readonly projectId?: string;
    readonly clientId?: string;
    readonly googleClientId?: string;
    readonly recaptchaSiteKey?: string;
    readonly children?: ReactNode;
    readonly onSuccess: () => void;
}

/**
 * Returns a fragment to be displayed in the search table for the value.
 * @param resource - The parent resource.
 * @param field - The search code or FHIRPath expression.
 * @returns The fragment to display.
 */
export declare function renderValue(resource: Resource, field: SearchControlField): string | JSX.Element | null | undefined;

export declare function RequestGroupDisplay(props: RequestGroupDisplayProps): JSX.Element | null;

export declare interface RequestGroupDisplayProps {
    readonly value?: RequestGroup | Reference<RequestGroup>;
    readonly onStart: (task: Task, input: Reference) => void;
    readonly onEdit: (task: Task, input: Reference, output: Reference) => void;
}

export declare function ResourceArrayDisplay(props: ResourceArrayDisplayProps): JSX.Element | null;

export declare interface ResourceArrayDisplayProps {
    /** The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension. */
    readonly path?: string;
    readonly property: InternalSchemaElement;
    readonly propertyType: string;
    readonly values: any[];
    readonly ignoreMissingValues?: boolean;
    readonly link?: boolean;
    readonly includeDescriptionListEntry?: boolean;
}

export declare function ResourceArrayInput(props: ResourceArrayInputProps): JSX.Element | null;

export declare interface ResourceArrayInputProps extends BaseInputProps {
    readonly property: ExtendedInternalSchemaElement;
    readonly name: string;
    readonly defaultValue?: any[];
    readonly indent?: boolean;
    readonly onChange?: (value: any[]) => void;
    readonly hideNonSliceValues?: boolean;
}

export declare function ResourceAvatar(props: ResourceAvatarProps): JSX.Element;

export declare interface ResourceAvatarProps extends AvatarProps {
    readonly value?: Reference | Resource;
    readonly link?: boolean;
}

export declare function ResourceBadge(props: ResourceBadgeProps): JSX.Element;

export declare interface ResourceBadgeProps {
    readonly value?: Reference | Resource;
    readonly link?: boolean;
}

export declare function ResourceBlame(props: ResourceBlameProps): JSX.Element | null;

export declare interface ResourceBlameProps {
    readonly history?: Bundle;
    readonly resourceType?: ResourceType;
    readonly id?: string;
}

export declare function ResourceDiff(props: ResourceDiffProps): JSX.Element;

export declare interface ResourceDiffProps {
    readonly original: Resource;
    readonly revised: Resource;
    readonly ignoreMeta?: boolean;
}

export declare function ResourceForm(props: ResourceFormProps): JSX.Element;

export declare interface ResourceFormProps {
    readonly defaultValue: Partial<Resource> | Reference;
    readonly outcome?: OperationOutcome;
    readonly onSubmit: (resource: Resource) => void;
    readonly onPatch?: (resource: Resource) => void;
    readonly onDelete?: (resource: Resource) => void;
    /** (optional) URL of the resource profile used to display the form. Takes priority over schemaName. */
    readonly profileUrl?: string;
}

export declare function ResourceHistoryTable(props: ResourceHistoryTableProps): JSX.Element;

export declare interface ResourceHistoryTableProps {
    readonly history?: Bundle;
    readonly resourceType?: string;
    readonly id?: string;
}

export declare function ResourceInput<T extends Resource = Resource>(props: ResourceInputProps<T>): JSX.Element | null;

export declare interface ResourceInputProps<T extends Resource = Resource> {
    readonly resourceType: T['resourceType'];
    readonly name: string;
    readonly defaultValue?: T | Reference<T>;
    readonly searchCriteria?: Record<string, string>;
    readonly placeholder?: string;
    readonly loadOnFocus?: boolean;
    readonly required?: boolean;
    readonly itemComponent?: (props: AsyncAutocompleteOption<T>) => JSX.Element | ReactNode;
    readonly onChange?: (value: T | undefined) => void;
    readonly disabled?: boolean;
    readonly label?: AsyncAutocompleteProps<T>['label'];
    readonly error?: AsyncAutocompleteProps<T>['error'];
}

export declare function ResourceName(props: ResourceNameProps): JSX.Element | null;

export declare interface ResourceNameProps extends TextProps {
    readonly value?: Reference | Resource;
    readonly link?: boolean;
}

/**
 * Low-level component that renders a property from a given resource, given type information.
 * @param props - The ResourcePropertyDisplay React props.
 * @returns The ResourcePropertyDisplay React node.
 */
export declare function ResourcePropertyDisplay(props: ResourcePropertyDisplayProps): JSX.Element | null;

export declare interface ResourcePropertyDisplayProps {
    readonly property?: InternalSchemaElement;
    /** The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension. */
    readonly path?: string;
    readonly propertyType: string;
    readonly value: any;
    readonly arrayElement?: boolean;
    readonly maxWidth?: number;
    readonly ignoreMissingValues?: boolean;
    readonly link?: boolean;
    /** (Optional) The `ElemendDefinitionType` to display the property against. Used when displaying extensions.  */
    readonly elementDefinitionType?: ElementDefinitionType;
    /** (Optional) If true and `property` is an array, output is wrapped with a DescriptionListEntry */
    readonly includeArrayDescriptionListEntry?: boolean;
}

export declare function ResourcePropertyInput(props: ResourcePropertyInputProps): JSX.Element;

export declare interface ResourcePropertyInputProps extends BaseInputProps {
    readonly property: ExtendedInternalSchemaElement;
    readonly name: string;
    readonly defaultPropertyType?: string | undefined;
    readonly defaultValue: any;
    readonly arrayElement?: boolean | undefined;
    readonly onChange?: (value: any, propName?: string) => void;
}

export declare function ResourceTable(props: ResourceTableProps): JSX.Element | null;

export declare interface ResourceTableProps {
    /**
     * The input value either as a resource or a reference.
     */
    readonly value: Resource | Reference;
    /**
     * Optional flag to ignore missing values.
     * By default, missing values are displayed as empty strings.
     */
    readonly ignoreMissingValues?: boolean;
    /**
     * Optional flag to force use the input value.
     * This is useful when you want to display a specific version of the resource,
     * and not use the latest version.
     */
    readonly forceUseInput?: boolean;
    /** (optional) URL of the resource profile used to display the form. */
    readonly profileUrl?: string;
}

export declare function ResourceTimeline<T extends Resource>(props: ResourceTimelineProps<T>): JSX.Element;

export declare interface ResourceTimelineMenuItemContext {
    readonly primaryResource: Resource;
    readonly currentResource: Resource;
    readonly reloadTimeline: () => void;
}

export declare interface ResourceTimelineProps<T extends Resource> {
    readonly value: T | Reference<T>;
    readonly loadTimelineResources: (medplum: MedplumClient, resourceType: ResourceType, id: string) => Promise<PromiseSettledResult<Bundle>[]>;
    readonly createCommunication?: (resource: T, sender: ProfileResource, text: string) => Communication;
    readonly createMedia?: (resource: T, operator: ProfileResource, attachment: Attachment) => Media;
    readonly getMenu?: (context: ResourceTimelineMenuItemContext) => ReactNode;
}

export declare function Scheduler(props: SchedulerProps): JSX.Element | null;

export declare interface SchedulerProps {
    readonly schedule: Schedule | Reference<Schedule>;
    readonly questionnaire: Questionnaire | Reference<Questionnaire>;
}

export declare class SearchChangeEvent extends Event {
    readonly definition: SearchRequest;
    constructor(definition: SearchRequest);
}

export declare class SearchClickEvent extends Event {
    readonly resource: Resource;
    readonly browserEvent: MouseEvent_2;
    constructor(resource: Resource, browserEvent: MouseEvent_2);
}

/**
 * The SearchControl component represents the embeddable search table control.
 * It includes the table, rows, headers, sorting, etc.
 * It does not include the field editor, filter editor, pagination buttons.
 * @param props - The SearchControl React props.
 * @returns The SearchControl React node.
 */
export declare function SearchControl(props: SearchControlProps): JSX.Element;

/**
 * The SearchControlField type describes a field in the search control.
 *
 * In a SearchRequest, a field is a simple string. Strings can be one of the following:
 * 1) Simple property names, which refer to InternalSchemaElement objects
 * 2) Search parameter names, which refer to SearchParameter resources
 *
 * Consider a few examples of how this becomes complicated.
 *
 * "name" (easy)
 *  - element definition path="Patient.name"
 *  - search parameter code="name"
 *
 * "birthDate" (medium)
 *  - refers to the element definition path="Patient.birthDate"
 *  - refers to the search parameter code="birthdate" (note the capitalization)
 *
 * "email" (hard)
 *  - refers to the search parameter code="email"
 *  - refers to the element definition path="Patient.telecom"
 *
 * In the last case, we start with the search parameter, and walk backwards to the
 * element definition in order to get type details for rendering.
 *
 * Overall, we want columns, fields, properties, and search parameters to feel seamless,
 * so we try our darndest to make this work.
 */
export declare interface SearchControlField {
    readonly name: string;
    readonly elementDefinition?: InternalSchemaElement;
    readonly searchParams?: SearchParameter[];
}

export declare interface SearchControlProps {
    readonly search: SearchRequest;
    readonly checkboxesEnabled?: boolean;
    readonly hideToolbar?: boolean;
    readonly hideFilters?: boolean;
    readonly onLoad?: (e: SearchLoadEvent) => void;
    readonly onChange?: (e: SearchChangeEvent) => void;
    readonly onClick?: (e: SearchClickEvent) => void;
    readonly onAuxClick?: (e: SearchClickEvent) => void;
    readonly onNew?: () => void;
    readonly onExport?: () => void;
    readonly onExportCsv?: () => void;
    readonly onExportTransactionBundle?: () => void;
    readonly onDelete?: (ids: string[]) => void;
    readonly onBulk?: (ids: string[]) => void;
}

export declare function SearchFieldEditor(props: SearchFieldEditorProps): JSX.Element | null;

export declare interface SearchFieldEditorProps {
    readonly visible: boolean;
    readonly search: SearchRequest;
    readonly onOk: (search: SearchRequest) => void;
    readonly onCancel: () => void;
}

export declare function SearchFilterEditor(props: SearchFilterEditorProps): JSX.Element | null;

export declare interface SearchFilterEditorProps {
    readonly visible: boolean;
    readonly search: SearchRequest;
    readonly onOk: (search: SearchRequest) => void;
    readonly onCancel: () => void;
}

export declare class SearchLoadEvent extends Event {
    readonly response: Bundle;
    constructor(response: Bundle);
}

export declare type SearchOptions = {
    debounceMs?: number;
};

export declare function ServiceRequestTimeline(props: ServiceRequestTimelineProps): JSX.Element;

export declare interface ServiceRequestTimelineProps extends Pick<ResourceTimelineProps<ServiceRequest>, 'getMenu'> {
    readonly serviceRequest: ServiceRequest | Reference<ServiceRequest>;
}

/**
 * Sets the array of filters.
 * @param definition - The original search request.
 * @param filters - The new filters.
 * @returns The updated search request.
 */
export declare function setFilters(definition: SearchRequest, filters: Filter[]): SearchRequest;

/**
 * Sets the offset (starting at zero).
 * @param definition - The original search request.
 * @param offset - The offset number.
 * @returns The updated search request.
 */
export declare function setOffset(definition: SearchRequest, offset: number): SearchRequest;

/**
 * Creates a new search request with the search offset at the specified page.
 * @param definition - The search definition.
 * @param page - The new page number
 * @returns The new search definition.
 */
export declare function setPage(definition: SearchRequest, page: number): SearchRequest;

export declare function setPropertyValue(obj: any, key: string, propName: string, elementDefinition: InternalSchemaElement, value: any): any;

export declare function setQuestionnaireItemReferenceTargetTypes(item: QuestionnaireItem, targetTypes: ResourceType[] | undefined): QuestionnaireItem;

/**
 * Sorts the search by the specified key, and optional direction.
 * Direction defaults to ascending ('asc') if not specified.
 * @param definition - The original search request.
 * @param sort - The sort key.
 * @param desc - Optional descending flag. Default is false.
 * @returns The updated search request.
 */
export declare function setSort(definition: SearchRequest, sort: string, desc?: boolean): SearchRequest;

/**
 * The SignInForm component allows users to sign in to Medplum.
 *
 * "Signing in" is a multi-step process:
 * 1) Authentication - identify the user
 * 2) MFA - If MFA is enabled, prompt for MFA code
 * 3) Choose profile - If the user has multiple profiles, prompt to choose one
 * 4) Choose scope - If the user has multiple scopes, prompt to choose one
 * 5) Success - Return to the caller with either a code or a redirect
 * @param props - The SignInForm React props.
 * @returns The SignInForm React node.
 */
export declare function SignInForm(props: SignInFormProps): JSX.Element;

export declare interface SignInFormProps extends BaseLoginRequest {
    readonly login?: string;
    readonly chooseScopes?: boolean;
    readonly disableEmailAuth?: boolean;
    readonly disableGoogleAuth?: boolean;
    readonly onSuccess?: () => void;
    readonly onForgotPassword?: () => void;
    readonly onRegister?: () => void;
    readonly onCode?: (code: string) => void;
    readonly children?: ReactNode;
}

export declare function SmartAppLaunchLink(props: SmartAppLaunchLinkProps): JSX.Element | null;

export declare interface SmartAppLaunchLinkProps extends AnchorProps {
    readonly client: ClientApplication;
    readonly patient?: Reference<Patient>;
    readonly encounter?: Reference<Encounter>;
    readonly children?: ReactNode;
}

export declare interface SmartSearchResponse {
    readonly data: {
        ResourceList: Resource[];
    };
}

/**
 * Sorts an array of resources in place by meta.lastUpdated ascending.
 * @param resources - Array of resources.
 * @param timelineResource - Optional primary resource of a timeline view. If specified, the primary resource will be sorted by meta.lastUpdated descending.
 */
export declare function sortByDateAndPriority(resources: Resource[], timelineResource?: Resource): void;

export declare function StatusBadge(props: StatusBadgeProps): JSX.Element;

export declare interface StatusBadgeProps {
    readonly status: string;
}

export declare type SupportedProfileStructureDefinition = StructureDefinition & {
    url: NonNullable<StructureDefinition['url']>;
    name: NonNullable<StructureDefinition['name']>;
};

export declare function ThreadChat(props: ThreadChatProps): JSX.Element | null;

export declare interface ThreadChatProps {
    readonly thread: Communication;
    readonly title?: string;
    readonly onMessageSent?: (message: Communication) => void;
    readonly inputDisabled?: boolean;
    readonly onError?: (err: Error) => void;
}

export declare function Timeline(props: TimelineProps): JSX.Element;

export declare function TimelineItem(props: TimelineItemProps): JSX.Element;

export declare interface TimelineItemProps<T extends Resource = Resource> extends PanelProps {
    readonly resource: T;
    readonly profile?: Reference;
    readonly dateTime?: string;
    readonly padding?: boolean;
    readonly popupMenuItems?: ReactNode;
}

export declare interface TimelineProps {
    readonly children?: ReactNode;
}

export declare function TimingInput(props: TimingInputProps): JSX.Element;

export declare interface TimingInputProps extends ComplexTypeInputProps<Timing> {
    readonly defaultModalOpen?: boolean;
}

/**
 * Toggles the sort of the search by key.
 * If the search is already sorted by the key, reverses the direction.
 * If the search is not sorted by the key, sort in ascending order.
 * @param definition - The original search request.
 * @param key - The field key name.
 * @returns The updated search request.
 */
export declare function toggleSort(definition: SearchRequest, key: string): SearchRequest;

export declare const useCachedBinaryUrl: (binaryUrl: string | undefined) => string | undefined;

/**
 * Returns the MedplumClient instance.
 * This is a shortcut for useMedplumContext().medplum.
 * @returns The MedplumClient instance.
 */
export declare function useMedplum(): MedplumClient;

/**
 * Returns the MedplumContext instance.
 * @returns The MedplumContext instance.
 */
export declare function useMedplumContext(): MedplumContext;

/**
 * Returns the Medplum navigate function.
 * @returns The Medplum navigate function.
 */
export declare function useMedplumNavigate(): MedplumNavigateFunction;

/**
 * Returns the current Medplum user profile (if signed in).
 * This is a shortcut for useMedplumContext().profile.
 * @returns The current user profile.
 */
export declare function useMedplumProfile(): ProfileResource | undefined;

/**
 * React Hook to keep track of the passed-in value from the previous render of the containing component.
 * @param value - The value to track.
 * @returns The value passed in from the previous render.
 */
export declare function usePrevious<T>(value: T): T | undefined;

/**
 * React Hook to use a FHIR reference.
 * Handles the complexity of resolving references and caching resources.
 * @param value - The resource or reference to resource.
 * @param setOutcome - Optional callback to set the OperationOutcome.
 * @returns The resolved resource.
 */
export declare function useResource<T extends Resource>(value: Reference<T> | Partial<T> | undefined, setOutcome?: (outcome: OperationOutcome) => void): T | undefined;

/**
 * React hook for searching FHIR resources.
 *
 * This is a convenience hook for calling the MedplumClient.search() method.
 *
 * @param resourceType - The FHIR resource type to search.
 * @param query - Optional search parameters.
 * @param options - Optional options for configuring the search.
 * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.
 */
export declare function useSearch<K extends ResourceType>(resourceType: K, query?: QueryTypes, options?: SearchOptions): [Bundle<ExtractResource<K>> | undefined, boolean, OperationOutcome | undefined];

/**
 * React hook for searching for a single FHIR resource.
 *
 * This is a convenience hook for calling the MedplumClient.searchOne() method.
 *
 * @param resourceType - The FHIR resource type to search.
 * @param query - Optional search parameters.
 * @param options - Optional options for configuring the search.
 * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.
 */
export declare function useSearchOne<K extends ResourceType>(resourceType: K, query?: QueryTypes, options?: SearchOptions): [ExtractResource<K> | undefined, boolean, OperationOutcome | undefined];

/**
 * React hook for searching for an array of FHIR resources.
 *
 * This is a convenience hook for calling the MedplumClient.searchResources() method.
 *
 * @param resourceType - The FHIR resource type to search.
 * @param query - Optional search parameters.
 * @param options - Optional options for configuring the search.
 * @returns A 3-element tuple containing the search result, loading flag, and operation outcome.
 */
export declare function useSearchResources<K extends ResourceType>(resourceType: K, query?: QueryTypes, options?: SearchOptions): [ResourceArray<ExtractResource<K>> | undefined, boolean, OperationOutcome | undefined];

/**
 * Creates an in-memory `Subscription` resource with the given criteria on the Medplum server and calls the given callback when an event notification is triggered by a resource interaction over a WebSocket connection.
 *
 * Subscriptions created with this hook are lightweight, share a single WebSocket connection, and are automatically untracked and cleaned up when the containing component is no longer mounted.
 *
 * @param criteria - The FHIR search criteria to subscribe to.
 * @param callback - The callback to call when a notification event `Bundle` for this `Subscription` is received.
 * @param options - Optional options used to configure the created `Subscription`. See {@link UseSubscriptionOptions}
 *
 * --------------------------------------------------------------------------------------------------------------------------------
 *
 * `options` contains the following properties, all of which are optional:
 * - `subscriptionProps` - Allows the caller to pass a `Partial<Subscription>` to use as part of the creation
 * of the `Subscription` resource for this subscription. It enables the user namely to pass things like the `extension` property and to create
 * the `Subscription` with extensions such the {@link https://www.medplum.com/docs/subscriptions/subscription-extensions#interactions | Supported Interaction} extension which would enable to listen for `create` or `update` only events.
 * - `onWebsocketOpen` - Called when the WebSocket connection is established with Medplum server.
 * - `onWebsocketClose` - Called when the WebSocket connection disconnects.
 * - `onSubscriptionConnect` - Called when the corresponding subscription starts to receive updates after the subscription has been initialized and connected to.
 * - `onSubscriptionDisconnect` - Called when the corresponding subscription is destroyed and stops receiving updates from the server.
 * - `onError` - Called whenever an error occurs during the lifecycle of the managed subscription.
 */
export declare function useSubscription(criteria: string | undefined, callback: (bundle: Bundle) => void, options?: UseSubscriptionOptions): void;

export declare type UseSubscriptionOptions = {
    subscriptionProps?: Partial<Subscription>;
    onWebSocketOpen?: () => void;
    onWebSocketClose?: () => void;
    onSubscriptionConnect?: (subscriptionId: string) => void;
    onSubscriptionDisconnect?: (subscriptionId: string) => void;
    onError?: (err: Error) => void;
};

/**
 * A low-level component to autocomplete based on a FHIR Valueset.
 * This is the base component for CodeableConceptInput, CodingInput, and CodeInput.
 * @param props - The ValueSetAutocomplete React props.
 * @returns The ValueSetAutocomplete React node.
 */
export declare function ValueSetAutocomplete(props: ValueSetAutocompleteProps): JSX.Element;

export declare interface ValueSetAutocompleteProps extends Omit<AsyncAutocompleteProps<ValueSetExpansionContains>, 'loadOptions' | 'toKey' | 'toOption'> {
    readonly binding: string | undefined;
    readonly creatable?: boolean;
    readonly clearable?: boolean;
    readonly expandParams?: Partial<ValueSetExpandParams>;
    readonly withHelpText?: boolean;
}

export { }
